# pnpm
[基础的东西官网讲的很详细，这里不在赘述](https://www.pnpm.cn/installation)，这里讲一下要注意的细节以及常见的问题

用新的东西的原因肯定是因为它好用，它解决了前人的痛点，那么在用 pnpm 之前我们在用什么呢
## npm 和 yarn
### 优点
- 扁平化依赖

- 如果项目很多，将会有大量文件需要重复下载
  
- 减少重复安装相同的依赖

npm 和 yarn 为了解决 node_modules 内的依赖嵌套过深的问题

将所有嵌套的依赖，无论是 dependencies 还是 devDependencies，全部拍平到 node_modules 下的同一级中

在安装新的包时，包管理器也会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决大量包重复安装的问题

### 缺点
- 扁平化依赖算法复杂，需要消耗较多的性能，依赖安装还有提速空间

- 扁平化依赖解决了不少问题，但是带来的**依赖非法访问**的问题。项目代码在某些情况下可以在代码中使用**没有被定义在 package.json 中的包**，这种情况就是我们常说的**幽灵依赖**

幽灵依赖最典型的例子就是类似于 `require('webpack')`，`require('qs')`这种

### 幽灵依赖可能会带来的问题
幽灵依赖 看似使用方便，是因为你在 package.json 中定义的某个依赖项依赖当前这个幽灵依赖

但是如果那一天，你定义的这个依赖不在依赖与这个幽灵依赖了，那么我们的代码就会报错，这就是非法访问依赖带来的风险

说的比较啰嗦，但是就是这么个意思

## 使用 pnpm 的优势
一下所有的优势都是 pnpm 基于软链接的依赖管理模式带来的好处

- 对于多个项目使用了同一个依赖，pnpm 只安装一次，后面再次使用都会直接使用链接的形式，减少安装
  
- 即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码

- node_modules 中文件目录清晰，基本上只看得到你在 package.json 中定义的依赖

- 同时这些依赖也只是一个链接，统一都指向同级目录下的 .pnpm 中

- 在 .pnpm 下面平铺了所有的依赖的，这些依赖也只是**链接**

- 默认情况下禁止幽灵依赖，带来了更安全更规范的访问

## 从 npm 转到 pnpm
全局安装 pnpm 后，先删除掉项目中 package-lock.json 以及 node_modules 文件，然后直接 install 就行

在你安装好依赖后 pnpm 会标记出你依赖之间的缺少的依赖，同时推荐给你对应的安装办法，这点很好
## 常见问题
### 安装好了项目跑不起来(一般都是幽灵依赖的原因)
`报找不到 qs 的错误`，死活找不到原因

[最后在这篇文章下面看到作者的回复，才恍然大悟](https://zhuanlan.zhihu.com/p/546400909)

因为 pnpm 依赖访问严格，规则清晰，界限分明

这样带来的好处是不再如以前一样容易出现依赖冲突，纠正我们之前的一些错误认知

自定义构建脚本中 `require('webpack')`，`require('qs')` 是典型的访问幽灵依赖的行为

pnpm 在默认配置下，你需要把 webpack 声明在项目的 package.json -> devDependencies 中才允许使用

我们看似利用依赖之间内部使用了相同的依赖，而直接引入 webpack 或者 qs 之类的依赖，`这在 pnpm 的规范下都是不允许的`

解决办法：老老实实的在 package.json 中声明好 qs

值得一提的是，网上的很多文章会让你用 `pnpm install --shamefully-hoist` 这个命令去解决问题

问题可能会被解决，但是它会将你的 node_modules 目录结构变得和 npm yarn 一样，那样将失去使用 pnpm 的意义，官方也不推荐